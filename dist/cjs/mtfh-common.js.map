{"mappings":";;;;AAAA,8CAA8C;AEA9C;AASO,MAAM,4CAAgB,CAAA,GAAA,YAAK,AAAD,EAAE,MAAM,CAAC;IACxC,cAAc;AAChB,IAEA,0DAA0D;CAC1D,0BAA0B;CAC1B,oBAAoB;CACpB,iBAAiB;CACjB,8BAA8B;CAC9B,2DAA2D;CAC3D,uDAAuD;CACvD,eAAe;CACf,6CAA6C;CAC7C,SAAS;CACT,OAAO;CACP,iDAAiD;CAEjD,kFAAkF;CAClF,+CAA+C;CAC/C,4BAA4B;CAC5B,MAAM;CAEN,gBAAgB;CAChB,MAAM;CAEN,2CAA2C;CAC3C,eAAe;CACf,yDAAyD;CACzD,0CAA0C;CAC1C,QAAQ;CACR,kBAAkB;CAClB,OAAO;CACP,6BAA6B;CAC7B,4CAA4C;CAC5C,8BAA8B;CAC9B,oBAAoB;CACpB,UAAU;CACV,QAAQ;CACR,mBAAmB;CACnB,OAAO;CACP,KAAK;CAEL,wFAAwF;CAExF,sFAAsF;;ADrDtF;AGAA;;;AAoBO,MAAM,2CACX,CAAC,UAA8B,CAAC,CAAC,GACjC,CAAe,MACb,CAAA,GAAA,yCAAa,AAAD,EAAE,GAAG,CAAe,KAAK,SAAS,IAAI,CAAC,CAAC,MAAQ,IAAI,IAAI;AAEjE,MAAM,4CAAc,CACzB,KACA,UAA+C,CAAC,CAAC,GAEjD,CAAA,GAAA,UAAM,AAAD,EAA+B,KAAK,yCAAa,UAAU;QAC9D,oBAAoB,KAAK;QACzB,GAAG,OAAO;IACZ;AAEK,MAAM,4CAAsB,CACjC,KACA,UAAuD,CAAC,CAAC,GAEzD,CAAA,GAAA,kBAAc,AAAD,EAA+B,KAAK,yCAAa,UAAU;;ADtC1E;;;;AHEA;AAEO,MAAM,4CAAO","sources":["lib/mtfh-common.tsx","lib/http/index.ts","lib/http/http.ts","lib/http/use-axios-swr/index.ts","lib/http/use-axios-swr/use-axios-swr.ts"],"sourcesContent":["// export { axiosInstance } from './http/http'\n\nexport { axiosInstance  } from './http'\n\nexport const Name = \"Callum\"\n\n","export * from \"./http\";\nexport * from \"./use-axios-swr\";","import axios, { AxiosError, AxiosRequestConfig, CancelTokenSource } from \"axios\";\n// import { v4 as uuid } from \"uuid\";\n\n// import { $auth, isAuthorised, logout } from \"../auth\";\n\nexport interface Config extends AxiosRequestConfig {\n  headers: Record<string, string>;\n}\n\nexport const axiosInstance = axios.create({\n  responseType: \"json\",\n});\n\n// axiosInstance.interceptors.request.use((reqConfig) => {\n//   const req: Config = {\n//     ...reqConfig,\n//     headers: {\n//       ...reqConfig.headers,\n//       Authorization: `Bearer ${$auth.getValue().token}`,\n//       ...(reqConfig.headers[\"skip-x-correlation-id\"]\n//         ? {}\n//         : { \"x-correlation-id\": uuid() }),\n//     },\n//   };\n//   delete req.headers[\"skip-x-correlation-id\"];\n\n//   if (req.method === \"patch\" && Object.keys(req.data || {}).includes(\"etag\")) {\n//     req.headers[\"If-Match\"] = req.data.etag;\n//     delete req.data.etag;\n//   }\n\n//   return req;\n// });\n\n// axiosInstance.interceptors.response.use(\n//   (res) => {\n//     if (res.config.method === \"get\" && res.data?.id) {\n//       res.data.etag = res.headers.etag;\n//     }\n//     return res;\n//   },\n//   (error: AxiosError) => {\n//     if (error.response?.status === 403) {\n//       if (isAuthorised()) {\n//         logout();\n//       }\n//     }\n//     throw error;\n//   },\n// );\n\n// export const createCancelToken = (): CancelTokenSource => axios.CancelToken.source();\n\n// export const isAxiosError = (e: unknown): e is AxiosError => axios.isAxiosError(e);\n","export * from './use-axios-swr';","import { AxiosError, AxiosRequestConfig } from \"axios\";\nimport useSwr, { Key, KeyLoader, SWRConfiguration, SWRResponse, mutate } from \"swr\";\nimport useSWRInfinite, {\n  SWRInfiniteConfiguration,\n  SWRInfiniteResponse,\n} from \"swr/infinite\";\n\nimport { axiosInstance } from \"../http\";\n\nexport type AxiosSWRError = AxiosError;\nexport type AxiosSWRResponse<T> = SWRResponse<T, AxiosSWRError>;\nexport type AxiosSWRInfiniteResponse<T> = SWRInfiniteResponse<T, AxiosSWRError>;\nexport type AxiosSWRConfiguration<T> = SWRConfiguration<T, AxiosError> &\n  AxiosRequestConfig;\nexport type AxiosSWRInfiniteConfiguration<T> = SWRInfiniteConfiguration<\n  T,\n  AxiosSWRError\n> &\n  AxiosRequestConfig;\n\nexport const axiosFetcher =\n  (options: AxiosRequestConfig = {}) =>\n  <ResponseData>(url: string): Promise<ResponseData> =>\n    axiosInstance.get<ResponseData>(url, options).then((res) => res.data);\n\nexport const useAxiosSWR = <ResponseData>(\n  key: Key,\n  options: AxiosSWRConfiguration<ResponseData> = {},\n): AxiosSWRResponse<ResponseData> =>\n  useSwr<ResponseData, AxiosSWRError>(key, axiosFetcher(options), {\n    shouldRetryOnError: false,\n    ...options,\n  });\n\nexport const useAxiosSWRInfinite = <ResponseData>(\n  key: KeyLoader<ResponseData>,\n  options: AxiosSWRInfiniteConfiguration<ResponseData> = {},\n): AxiosSWRInfiniteResponse<ResponseData> =>\n  useSWRInfinite<ResponseData, AxiosSWRError>(key, axiosFetcher(options), options);\n\nexport { mutate };\n"],"names":[],"version":3,"file":"mtfh-common.js.map"}